viewcontroller有两种类别：content_viewController & container_viewController 前者是主要创建的 用于显示视图信息；后者用来作为容器以便不同层级的viewController之间的便携跳转
content_viewContrller会管理其rootView及其subview的所有；但是container_viewcontroller只会管理它自己的rootView和被加入到它的childViewController的rootView的尺寸，但是不管理childViewController的视图内容，由其自行管理；
viewController有一个功能是用来管理视图的继承树：每一个viewController都有且只有一个根视图-rootView，根视图能够包含该viewCOntroller所需要呈现的所有内容，视图继承树之间的所有权关系都为strong


UIWindow：每一个UIWindow都只能有一个rootViewController用于适配这个UIWindow的尺寸，但是并没有限定UIWindow的数量；
containerViewController：UIKIt内建提供的容器视图有UINavigationController   UISplitViewController UIPageViewController
viewController虽然继承自UIResponder，但是一般它不直接对事件进行处理，转而使用专门化的对象比如触摸控件、手势识别器；接受来自系统的事件或是app通知；作为代理对象处理相关事件；

使用storyBoard进行启动时，app会使用故事板文件对view对象进行实例化，链接letout和action，分配根视图控制器的根视图，然后调用awakeFromNib：方法最后viewDidLo：

app状态恢复和保存：主要使用UIApplicationRestoration协议类：
	viewController 可以协助保存app进入挂起或是后台时候的状态，但是需要完成两件事：
	1、在保存时为视图的restoreIdentifier属性分配标签如果一个视图需要进行状态的保存，则其父视图的状态也需要进行保存；未保存的视图在进行app重新载入时并没有被删除，而是被uikit重新初始化；
	   如果是对tableView或者是collectionview进行状态保存，还需要一个数据源协议：UIdatasourceModeAssociation
	   需要在Appdelegate中调用方法：-(BOOL)application:ApplicationshouldSaveapplicationState: 并返回yes
	2、在恢复时告知app如何定位某个特定的viewcontroller

	详细设置：
	对于启动流程而言,需要在application：willfinishLaunch：方法中设置window及根视图的相关信息；
	此后系统调用application:shouldRestoreSecureApplicationState:方法确认系统是否应该从磁盘中恢复视图的state，此处应该返回yes；
	在appdelegate中先行检查是否实现了application:viewControllerWithRestorePathIdentifier:coder:方法，如实现此方法则从此进行恢复；
	未实现上述方法，则进入window的根视图控制器中查找，viewcontroller的viewcontrollerWithRestorePathIdentifier:coder:方法进行实例化恢复；
	在viewcontroller中调用decoderrestoreStatewithcoder:方法进行恢复；
	
	对于后台、挂起流程而言：
	在Appdelegate中调用application :shouldeSaveSecureApplicationState:方法判断是否应该对状态进行保存，此处返回yes；
	在viewcontroller中调用encoderestorableStatewithcoder:方法进行数据储存；

viewcontroller的视图呈现：
	呈现的形式：全屏-》UIModalPresentationFullScreen / UIModalPresentationOverFullScreen（不删除下方视图的空间）
		    非全屏：UIModalPresentationPageSheet  /UIModalPresentationFormSheet
			   UIModalPresentaionPopover:类似一种气泡弹出的形式，只是遮蔽住下方视图空间的一部分，点击popover view的外部视图时，popover view自动dismiss；
		    自定义：自定义的视图呈现方式---UIModalPresentationCustom，需要创建一个继承自UIPresentationController的类，并自行实现视图位置和尺寸的方法；
 	视图跳转时可以使用动画，在modalTranslationStyle属性中进行设置；
        呈现方法：showViewController:sender\showDetailViewController:sender: 可以让视图控制器自身来决定该如何呈现视图；
		  presentViewController:animate：complete：\presentDetailViewController:animate:complete:总是使用modal来呈现视图，即总是将视图表现为模态视图；
	视图跳转：需要自行初始化将要呈现的视图控制器；自行设定将要呈现的视图控制器的呈现方式，比如使用全屏或是模态视图，虽然并不一定会被系统采用；
		  自行设定将要呈现的视图控制器的跳转动画--modalTransitionStyle属性；调用当前视图的showViewController：sender方法；
		  
		  调用 presentViewController:animated:completion: 方法的视图控制器可能不是实际执行模态呈现的视图控制器。 presentationStyle决定了如何呈现该视图控制器，包括呈现视图控制器所需的特征。
		  例如，fullScreen必须由全屏视图控制器启动。 如果当前呈现的视图控制器不合适，UIKit 会遍历视图控制器层次结构，直到找到适合的视图控制器层次结构。 
		  完成模态呈现后，UIKit 会更新受影响的视图控制器的presentingViewController 和presentedViewController 属性。
	
	使用segue跳转：segue的init方法和perform方法会被系统自动调用，实现自定义的segue时需要将这两者重写；

转场动画：转场动画有两种形式：presentation和dismiss；当使用除了modalStyleCustom之外的其他形式的style时系统使用内置的转场动画完成。使用modalStyleCustom时需要使用转场代理对象来完成
	  转场代理对象需要显示的赋给视图控制器的transitionDelegate属性；
