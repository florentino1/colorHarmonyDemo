iOS原生的图像系统提供了三种混合的方式供使用：UIKIT为视图提供高级别的绘制功能；CG作为低级别的api补充，用以支持UIKIT：CA为UIKIT视图的变换以及动画提供支持

IOS提供两种形式的图形创建：使用OpenGL 和使用Quarz、CA和UIKIT的原生渲染；quartz是一种基于路径绘制、抗锯齿渲染的方法；UIKIT提供了对quartz的oc封装，CA在底层提供支持

并不是所有的UIKIT类都是线程安全的，所以建议在主线程中进行UI的更新；在IOS中无论构建视图的技术如何，最终视图的呈现都是由UIKIt及其子类来完成的；对于系统内建的视图类，系统可以自动完成绘制，而自定义的视图类必须手动编制绘制方法；

除了直接在当前屏幕上进行绘制外，UIKIT还允许进行离屏绘制位图或是PDF的图形上下文；当发生离屏绘制时，有关视图绘制的概念将不再使用，比如绘制周期等；

上一章有提到过UIKIT的绘制模式是按需绘制；当处于视图重绘期间才会产生图形上下文，此时系统才能够调用drawrect：方法进行视图重绘。调用drawrect方法结束后的视图将自身标记为已更新状态，等待其他时间到达触发更新周期；

在ios中所有的绘制都发生在图形上下文中，从概念上来讲一个图形上下文时一个描述绘制在何处且如何发生的包含基本绘图属性比如绘制的颜色、剪切区域、线宽、字体等等信息的对象；
每一个图形上下文都有三个坐标系：绘图坐标系（bounds空间）、视图坐标系（frame空间）以及设备坐标系（即物理设备的屏幕像素点）

在开始绘制之前，UIKIt会产生一个初始坐标系与屏幕是一比一映射的，使用的是左上角为原点的坐标系统；每一个view都有一个CTM变换矩阵，用于将相对坐标系统中的点转化到一个固定的视图坐标系中去；

物理像素和逻辑点的区别于联系：在垂直方向绘制一条一个像素宽的直线时，如果直线全部位于像素点上则其是一条黑色的线，如果直线落在相邻两个像素的中间，则变成了两条灰色的线；而逻辑点这个概念不等同于像素；一个点可能包含多个像素；

每一个视图对象都会讲创建图形上下文作为自动配置的一部分在调用drawrect：方法之前将其创建，图像上下文是一个cgcontextRef 对象；

使用UIGraphicsGetCurrentContex（）方法可以获取到当前的图形上下文；如果使用CG进行绘图务必要注意CG使用的坐标系原点在左下角，而IOS的坐标系原点在左上角；可以使用CTM进行变换

IOS的Quartz为所有的颜色空间都提供给了支持；在移动设备上使用RGB颜色空间比较恰当；但是UIColor类为颜色提供了RGB HSB以及灰度值的创建形式，所以不必自行决定使用哪一种颜色空间，UIcolor对象会自行选择

使用Quartz和UIKIt进行绘制：
	Quartz时IOS中原生绘图技术的通用名称，核心是CG；UIKIT并不是专门用来支持绘制的工具，因为CG已经完全的提供了相关的工具；相反，UIKIt为UIKIT类的视图控件绘制提供了支持：UIColor,UIfont,UIImage,UIScreen UIBezierPath以及相关创建图像、位图、上下文的函数；
	图形上下文包含已保存的图形状态的栈，当 Quartz 创建图形上下文时，栈为空；使用 CGContextSaveGState 函数将当前图形状态的副本推送到栈。此后，对图形状态所做的修改会影响后续的绘图操作，但不会影响存储在栈中的副本。
	完成修改后，可以使用 CGContextRestoreGState 函数将保存的状态弹出堆栈顶部，从而返回到先前的图形状态。 以这种方式推送(push)和弹出(pop)图形状态是返回先前状态的快速方法，并且无需单独撤消每个状态更改。 它也是将状态的某些方面（例如剪切路径）恢复到其原始设置的唯一方法。
	在 Core Graphics 框架中，有两种方法可以修改CTM。 可以使用CGContext Reference中定义的 CTM 操作函数直接修改 CTM 。 还可以创建CGAffineTransform结构，应用所需的任何转换，然后将该转换连接到 CTM 。
        使用仿射变换可以对变换进行组装，然后将它们一次性应用到 CTM 。 还可以评估和转化仿射变换，使用它们来修改代代码中的点，大小和矩形值
	一般，将一个视图绘制在原点位置，然后按照需要的顶点将视图转化过去，这样可以使得绘制好的视图得到重用；
	在绘制中使用CG渲染后想要将正确的视图反应在UIView中时需要将坐标系进行翻转：更改坐标系的原点，然后将y轴乘以-1；
	CGContextSaveGState(graphicsContext);
	CGContextTranslateCTM(graphicsContext, 0.0, imageHeight);
	CGContextScaleCTM(graphicsContext, 1.0, -1.0);
	CGContextDrawImage(graphicsContext, image, CGRectMake(0, 0, imageWidth, imageHeight));
	CGContextRestoreGState(graphicsContext);
	如果一开始就是用一个CGImageRef对象来初始化UIImage对象，UIKIt会自动完成坐标系的转化，因为每一个UIImage对象都由一个CGImage对象来支持；

	两种坐标系绘制得到的视图可能存在镜像对称的问题，需要进行调整：startAngle和endAngle；同理shadow因为CTM的转化也不能够正确的显示；
	
	CAAnimation对象的核心技术时layer层对象，layer层对象更像是一个轻量级的对象，负责视图绘制相关工作的快速实现，将渲染和实现代码分离。程序员只需要将视图的框架绘制好即可；更像是一个模型对象；

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
******************************************************************************************************************************************************************************************************************************************************************************
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

使用贝塞尔曲线进行绘制：

UIBezierPath对象可以用来绘制基于矢量的路径。其基于CG，UIKIT提供了OC的相关封装；还可以使用路径为当前图形上下文定义剪切区域，然后可以使用该剪辑区域修改该上下文中的后续绘制操作

CGPathRef对象为UIBezierPath对象提供支持；

子路径：每一组线或是曲线段构成一个子路径，子路径的末尾为下一个子路径的起点，由moveToPoint:方法进行分割；

创建UIBezierPath对象的方法：    创建path对象
			    	设置对整个path对象都统一的属性：如描边路径的线宽，joinStyle等；
				使用moveToPoint:方法设置path的起点；
				添加直线或是曲线来构建子路径；
				封闭路径：使用closepath方法直连最后一条子路径的末尾与起点子路径的起始点；

构建路径时应该相对于(0,0)点, 这样做可以更轻松地在以后移动路径;如果路径相对于原点定向,当重新定位时所需要做的就是将具有平移因子的仿射变换应用于当前图形上下文;修改图形上下文相对于修改所绘制的对象本身，优点是可以通过保存和恢复图形状态轻松撤消转换（CGContentSaveGState()）；

要绘制路径对象，使用描边和填充方法(stroke and fill)，这些方法在当前图形上下文中渲染路径的线段和曲线段。 渲染过程涉及使用路径对象的属性栅格化线和曲线段，栅格化过程不会修改路径对象本身，因此可以在当前上下文或另一个上下文中多次渲染相同的路径对象。

栅格化/光栅化： 将矢量图转化为像素点的过程

创建UIBezierPath：
使用moveToPoint:方法设置起点，然后调用addLineToPoint：方法添加子路径即可构建path；最后使用closePath：方法关闭路径时还会自动绘制结束点到起始点的直线；

创建弧线arc：
使用bezierPathWithArcCenter:radius:startAngle:endAngle:clockwise: 方法添加弧线，采用这种方式创建的弧线默认是采用顺时针的方式构建圆弧（clockwise=YES），起始角和结束角需要进行转化，两者均以弧度为单位；
无法在UIBezierPath中直接使用arc弧线，需要对CGPathRef模型对象的数据结构进行直接的修改后才可以将UIBezierPath对象和arc对象连接；

创建曲线curve：
UIBezierPath类支持将三次(Cubic)和二次(Quadratic)贝塞尔曲线添加到路径。曲线段从当前点开始指定的点结束，使用起点和终点之间的切线(tangent)以及一个或多个控制点来定义曲线的形状；
	需要添加三次曲线：addCurveToPoint:controlPoint1:controlPoint2:
	需要添加二次曲线：addQuadcurvetoPoint:controlPoint:

创建椭圆及矩形：
使用UIBezierPath类的bezierPathWithRect: 和 bezierPathWithOvalRect:方法可以很简单的创建矩形和椭圆的新对象；
如果需要在已有的path对象中添加新的矩形，需要从movetopoint方法开始一步一步绘制新的矩形，然后调用closepath方法关闭路径才可以；
如果需要在已有的path对象中添加新的椭圆，最简单的方式是使用CG的CGPathAddEllipsInRect:方法进行绘制；也可以使用UIBezierPath类的二次方法：addQuadCurveToPath:controlpoint:方法来近似模拟；

修改Path对象：
修改path对象有两种形式：全部使用CG的函数来修改和混合使用CG与UIBezierPath的方法；
	全部使用CG的方法：  新建一个mutable型的CGPath；创建该CGPath的相关属性、路径等信息； 取得一个UIBezierPath对象；将该CGPath对象赋值给UIBezierPath对象的CGPath属性即可；
	混合的方法：取得一个UIBezierPath对象的CGPath对象；将该CGPath对象做mutable copy；修改copy的CGPath对象；将修改后的CGpath对象赋值给该UIBezierPath对象的CGPath属性；

渲染创建的path对象：
当完成path对象的构造之后，可以使用Strock或者fill方法进行描边或者填充；在调用描边或填充方法之前需要确认以下事项：
	1、使用 UIColor 类的方法设置所需的描边和填充颜色。
	2、将形状放在目标视图中所需的位置：如果创建了相对于点（0,0）的路径，则可以将适当的仿射变换应用于当前绘图上下文
	3、更新路径对象的绘图属性。在渲染路径时， UIBezierPath 实例的绘图属性会覆盖与图形上下文关联的值。

CG的命中测试：
如果使用指定的路径绘制模式对路径进行描边或填充不透明颜色时，该点位于绘制区域内，则该点包含在图形上下文的路径内；
要确定是否在路径的填充和描边部分上发生了触摸事件，可以使用 UIBezierPath 的containsPoint: 方法。此方法针对路径对象中所有已关闭的子路径测试指定点，如果它位于任何这些子路径上或内部，则返回YES。
	要点：containsPoint: 方法和Core Graphics命中测试仅在封闭路径上运行。对于打开的子路径上的命中，这些方法始终返回 NO 。
	      如果要在打开的子路径上执行命中检测，则必须先创建路径对象的副本，然后在测试点之前关闭打开的子路径。
如果要对路径的描边部分（而不是填充区域）进行命中测试（即线段是否相交的问题），则必须使 用Core Graphics 。
bool CGContextPathContainsPoint(CGContextRef c, CGPoint point, CGPathDrawingMode mode)方法允许测试当前分配给图形上下文的路径填充或描边部分上的点。

CGPathDrawingMode：共有5种，分别是使用非零缠绕规则和奇偶规则的fill模式，分别使用非零缠绕规则和奇偶规则的Strock模式，以及fill和strock混合并使用奇偶规则的模式；
非零绕组规则：non_zero winding rule 从一个点p发射出无线长的射线，射线与path的矢量路径相交；
		矢量路径的方向与射线顺时针🔃相交则相交点计数+1；矢量路径的方向与射线逆时针🔄相交，则相交点计数-1；
		当相交点计数==0，表示点p在矢量路径区域之外，不需要被fill或者strock；否则点p在矢量路径区域之内，需要被fill或者strock；

奇偶规则：even_odd 默认使用的规则。从一个点p发射出无线长的射线，射线与path的矢量路径相交；
		相交点计数如果是偶数，则表明点p在矢量路径区域之外，否则点p在矢量路径区域之内；

缠绕规则：缠绕规则多与以上两种规则合并使用；
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------$
***********************************************************************************************************************************************************************************************************$
___________________________________________________________________________________________________________________________________________________________________________________________________________$

实际进行视图绘制时遇到的问题：
1、Quartz 2D、CG、OpenGL使用的坐标系是LLO，UIKIt使用的坐标系是ULO；

2、UIKIt实际提供了一系列的方法可以供标准视图对象直接使用：
	drawAtPoint:
	drawInRect:
	drawAtPoint:withAttributes:
	drawInRect:withAttributes:     等等方法提供直接在某处或是某个区域内直接进行绘制，而不必进行坐标系的转化；
	UIRectFill()
	UIRectFrame()			等方法直接提供了视图的描边和填充；
	UIBezierPath类对象实例可以直接调用以上方法进行视图的绘制；

3、Quartz 2D即CG提供的一系列更加具有自定义可能性的方法：
	一般而言需要创建自定义图形上下文：UIGraphicsGetCurrentContext()方法创建当前的自定义图形上下文；
	函数前缀为CGContext-- 如CGContextMoveToPoint： CGContextAddLineToPoint: CGContextClosePath: CGContextDrawPath()  CGContextStrokePath()等；
	使用此类函数绘制的内容需要进行坐标系的转化后才能在视图中进行正确的显示：设计到坐标系的平移、旋转和缩放；
		X轴的对称变换：缩放因子x=1，y=-1；；Y轴的对称变换：缩放因子x=-1，y=1；原点对称变换：缩放因子x=-1，y=-1；经过这三种变换的视图内容会发生镜像翻转；
	Quartz 2D提供的变换方主要有CTM 和 仿射变换affine；
		CTM变换主要有CGContextscaleCTM: CGContextRotateCTM: CGContextTranslateCTM;  当进行对称变换后有可能会出现视图超出显示范围的情况需要进行平移才能正确显示；

		affine：仿射变换可以累积多次变换的效果而CTM只能单条执行；主要的函数有：CGAffineTransformMakeRotation：CGAffineTransformMakeScale： CGAffineTransformMakeTranslation：
			CGAffineTransformRotate： CGAffineTransformScale： CGAffineTransformTranslate： 
			当所需要执行的变换累积完成之后，需要将仿射变换的矩阵链接答CTM才能够让变换生效：CGContextConcatCTM（）；
