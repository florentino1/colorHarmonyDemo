core animation 可以完成大部分的动画内容，通过图形加速生成的高帧率的、平滑的动画同时还不会加重CPU的负载降低程序的执行；

core animation本身并不是一个绘制视图的工具，其核心是layer对象，layer对象同样也存在view的父子关系；可以额外的给视图添加一个layer对象，但是需要自行管理；

core animation的layer对象并不是view对象的替代品，不能创建一个完全基于layer对象的用户界面；相反其作为获得view更加好的性能的一个支持，以便view对象能够以更佳的性能呈现视图及动画；
为了达到这一目的，core animation将缓存视图的内容形成可以供硬件直接使用的位图；layer对象只是管理位图图像的一个容器；

core animation 将当前视图进行位图形式的缓存，当视图的内容发生变化时，直接将视图的内容和变化的信息发送大图形硬件进行绘制，而不是像传统的基于view的方法一样调用drawrect：方法进行CPU内的离屏渲染；

anchor：position
	core animation使用了两种坐标系，coordinate system 和unit system（0~1）；
	position是layer使用coordinate system的一个值，代表的是该视图的layer中心点在父视图坐标系中的相对位置；
	anchor是layer使用unit system的一个值，代表的是该视图的中心点，基于该视图本身的相对坐标；anchor 和position的位置总是完全重合的
	在这个概念中，anchor是主要的，初始时默认anchor是本视图的中心位置即（0.5,0.5）；position的值是anchor在父坐标系的位置，完全是通过anchor的值与frame的值通过计算得到；

layer 对象有两种transform的模式：layer对象的transform属性将对layer本身及其子layer ：sublayer进行完全相同的transform；
				 layer对象的sublayerstransform将仅对子视图进行相应的transform；

使用core animation的app都具有三个类型的layer对象集合：
	1、layer tree对象：在layer tree中的对象都是模型对象，保存了呈现动画需要的target值，对于任意layer属性的修改都是通过修改layer tree对象完成的；
	2、presentation tree对象：在presentation tree中的对象保存的是动画在当前屏幕进行显示时的current值；这个tree内的对象不应该被修改，但是可以read这个tree内的对象并创建新动画的起点；
	3、render tree对象：render tree中的对象呈现的是实际的动画，对于core animation是私有的；
	App主要是与layer tree中的对象进行交互，当需要在动画中获得当前值的时候可以调用layer tree中对象的presentationlayer属性返回与之相关的presentation tree中对象；

layer 与view的关系：
	1、layer对象不负责进行视图的绘制
	2、layer对象不能够响应事件
	3、layer对象不在响应链者链
	4、在ios中每一个view对象都由一个layer对象提供支持---即layer-based-view
	5、还可以创建layer对象但是该layer对象不与view进行关联，而是将该单独的layer内嵌到其他与视图相关联的layer对象中，达到复用的目的；
	6、在ios中，系统会自动创建与view相关联的layer对象并进行同步的保存，view对象是对应的layer的对象的代理对象；

修改layerclass：在视图display之前，视图对象会调用其layerclass方法返回其layer对象，可以通过复写该方法返回一个不同的layerclass以改变view的backedlayer，但是视图一旦创建就不能再改变其layerclass；

layer：content：
	layer是一个数据对象管理者app提供的内容，layer的content属性维护着一个包含可视化数据的位图；
	可以通过layer对象的content属性对layer的content进行修改，比如直接提供一个image对象（CGImageRef）到layer.content；
	为layer设置一个Delegate对象，然后复写Delegate对象的draw方法对layer对象的内容进行自定义绘制；
	layer对象的delegate对象实现了CALayerDelegate协议中的诸多方法以便于在运行时对layer的内容进行修改，在ios中应该只复写draw方法而不是类如displayLayer: 或者drawlayer：incontext:方法；
        CALayer对象的display方法和drawInContext：方法的效果不相同，后者是在特定的图形上下文中对content进行绘制，前者需要定义多种图像当前状态的属性值；
	layer对象的contentGravity属性决定了位图对对象如何在context的bounds区域内进行尺寸适配，如果两者的aspect radio（纵横比）不同，可能会导致image无法正确进行显示；
		contentGravity属性有两种类型的常量可供选择：基于位置的常量能够使image与bounds的边缘或者圆角进行对齐而不进行拉伸缩放；基于scale的常量有可能会不保证image的纵横比；
	contentScale：比例因子用于在直接使用bitmap image设置layer的content时，需要显式的指定image的contentScale以便与当前屏幕的分辨率进行适配，默认值为1.0；

layer对象可视的装饰属性：
	比如backgroundColor和borderwidth、bordercolor，默认值前者是nil；
	为layer对象设置圆角时实际上还使用了transparency mask，所以只会作用于background和border这两个内容，而不会对layer的content属性产生影响，除非设置了layer的masktobounds属性，但是会产生离屏渲染；
	设置阴影时如果设置了masktobounds属性，那么阴影效果也会被剪裁掉，因为shadow也是content的一部分，但是阴影位于layer bounds的外部；此时就需要人为创建一个额外layer来部署阴影效果；

使用动画：
	隐式动画使用默认的参数进行动画，包括动画的时间、动画的属性等；但是显式动画需要自行配置动画对象的相关属性；
	对lay tree中的对象进行修改时，对象基本上能够立即对这些修改做出反馈；但是如果修改的是可视化的属性，那么core animation会在对象的当前值和目标值之间创建隐式动画，然后在下一个周期进行更新；

创建显式动画：
	先创建一个CABasicAnimation对象，然后修改这个对象的参数，最后将这个对象添加到layer中；
	建议设定显式动画的fromValue属性，否则系统将使用需要进行动画的对象的当前值作为fromValue的值；
	更重要的一点是：与隐式动画不同的是，显式动画就只是动画，呈现动画的效果后就被移除，而不会对需要动画的对象属性产生任何的作用；所以显式动画结束之后，系统会从动画的toValue设置回fromValue；
	隐式和显式动画通常在当前 run loop 循环结束后开始执行，并且当前线程必须有一个 run loop 才能执行动画。

使用关键帧动画
	动画从设定的起始值到目标值进行运动，使用关键帧动画可以设定动画运行过程中的一系列目标值，使得动画可以按设定的path进行运动而不必是线性的；
	创建CGpathRef对象，使用CGPath的相关方法绘制出关键帧路径；	
	创建CAKeyframeAnimation动画对象，设置CAKeyframeAnimation对象的path属性为关键帧路径，最后将该动画对象添加到layer中；

设置关键帧的值：
	关键帧的值储存在一个数组之中，数组元素的类型取决于关键帧改变的layer的属性；
	对于位置的移动，可以使用CGPathRef对象直接进行动画；可以使用CGPoint点作为layer的position属性变化值，但是需要将CGPoint的结构体转化为NSValue对象才能保存在数组中供使用；
		如果是单个点的变化如alpha的变化，那么需要封装为NSnumber对象保存；变换矩阵封装为NSValue，content封装为CGImageRef对象后强制转化为id类型；color封装为CGColorRef对象；
	对于关键帧时间的控制使用：calculationMode属性来控制--kCAAnimationLiner kCAAnimationCubic kCAAnimationPaced kCAAnimationDiscrete等
	使用keytime属性来控制：但是keytime属性对kCAAnimationPaced常量不适用，此时keytime属性会被忽略；是一个执行时间占比的数组，数组的首元素和尾元素是0.0和1.0；
	使用timeFunction属性来控制； 

删除动画：
	removeAnimationForKey：使用创建animation时设置的key来删除动画，必须要保证创建动画时设置的key不为nil；
	removeallAnimations 删除所有动画，系统会对lay tree 对象进行重绘；注意此处的重绘时使用信息指的是动画指定的toValue的信息，与from value是不一致的；
		而presentation tree中对象的current value处于这两者之间，所以为了避免动画中途被移除时导致的layer属性的突变，需要将layer重绘时的状态设置为presentation tree中的状态值；
	不能从layer中直接删除隐式动画；
创建组动画：
	CAAnimationGroup 创建一个group对象，它是一个数组，可以包含其他的动画对象，然后对数组中的动画对象使用相同的duration 最后添加到layer中使得数组中的动画对象得以同时执行；

启动动画的途径：如果要使用 Core Animation 类来启动动画，则必须从基于视图的动画块内部发出所有 Core Animation 调用。 UIView 类默认禁用图层动画，但在动画块内重新启用它们。
	block块外部的core animation调用使用默认的时间来执行，忽略人为设置的各种参数；
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

layer的继承树：

layer之间的关系与view之间的关系类似，均可以构成兄弟关系或是父子关系；具有父子关系的layer，sublayer的诸多特性会受到parentlayer的影响，
	比如sublayer的content会覆盖在parent之上，sublayer使用的是相对于parentlayer的坐标系，还会受到parentlayer关于transform的影响；

layer相关的添加、插入以及移除的方法同view的方法类似；
superlayer的某些属性对于sublayer是可见的，比如speed，默认值为1，当super和sublayer都将该属性设为2时，super按照2倍速进行，但是sublayer按照2*2 倍速进行；

每个layer定义自己的本地时间空间，并使用该时间空间将动画的开始和结束与系统的其余部分同步。 这些时间空间默认是同步的；
但是，如果更改一组图层的speed属性，这组图层的时间空间也会相应更改。 可以使用时间转换函数来处理任何此类问题并确保两个层的时间同步。
convertTime: from/tolayer:

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

CATransition：  使得layer从一个状态完成到另一个状态的转变，其中filter在ios下不可用；
		相关的属性为startProgress 和 endProgress ，默认值为0和1。表示的是动画该从整个过程的多少百分比开始显示；

CAMediaTiming： 计时是动画的重要组成部分，Core Animation中可以通过 CAMediaTiming 协议的方法和属性为动画指定精确的计时信息	
		在core animation中有两个类实现了CAMediaTiming协议：CAAnimation类和CALayer类，所以在这两个类及其子类中可以为动画使用精确的计时信息；
		在这两个类中都内置有计时器用于计算各自layer实例的本地时间，通常来讲两个不同的layer实例之间本地时间的差异很小，可以认为是相同的；
		但是layer实例的本地时间可以被superlayer的相关属性或者是本身的某些属性影响，比如speed属性会加速layer的本地时间
		CACurrentMediaTime （）函数获取当前layer下的CPU时钟时间:返回一个CFTimeInterval类型的CPU绝对时间，然后转化为以秒s为单位的值；得到的时间是当前设备距离本次启动经过的时间；
		Getting a layer’s current local time：CFTimeInterval localLayerTime = [myLayer convertTime:CACurrentMediaTime() fromLayer:nil];
		
		Core Animation，时间都是相对的，每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。
		一般来说，动画都是在下一个更新周期开始时进行的，调用begintime属性可以达到延时的效果；
		beginTime指定了动画开始之前的的延迟时间。这里的延迟从动画添加到可见图层的那一刻开始测量，默认是0（就是说动画会立刻执行）。begintime受到speed的影响；
		timeOffset和beginTime类似，但是和增加beginTime导致的延迟动画不同，增加timeOffset只是让动画快进到某一点，例如，对于一个持续1秒的动画来说，设置timeOffset为0.5意味着动画将从一半的地方开始。
		和beginTime不同的是，timeOffset并不受speed的影响。所以如果你把speed设为2.0，把timeOffset设置为0.5，那么你的动画将从动画最后结束的地方开始；
		timeoffset只是动画运行到某个比例的标记而已，它并不执行实际的计时；


		
		父对象时间转化到子对象本地时间的两个过程：
		1、父对象时间转换为子对象“活跃的本地时间”：包括对象在父对象的时间轴中出现的时间点以及它相对于父对象的播放速度。
		2、从“活动本地时间”到“基本本地时间”的转换： 计时模型允许对象多次重复其基本持续时间，并且可以选择在重复之前向后播放；

		设置动画的speed属性为0可以暂停动画，但在动画被添加到图层之后不太可能再修改它了，所以不能对正在进行的动画使用这个属性。
		给图层添加一个CAAnimation实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。
		相反，直接用-animationForKey:来检索图层正在进行的动画可以返回正确的动画对象，但是修改它的属性将会抛出异常。

		动画默认在下一个更新周期开始时开始运行，此时根据动画的属性决定不同的视觉呈现：
		begintime指定动画相对于父对象开始执行的时间；
		offsetTime指定对象相对于活跃的本地时间什么时刻在屏幕上显示
		speed会加速活跃的本地时间，将会影响到各类关于在活跃本地时间内进行计时的属性，比如begintime，duration等；但是对于offsetTime不会产生影响；

CATransaction： 对layer对象任何的修改都可以看成是一种事务，此处的事务和数据库中的事务不能等同；一般来说系统会创建隐式的transaction对象来处理layer中的动画；
		通过调用CATransaction的begin方法隐式的创建了一个CATransaction对象，通过调用其commit方法来结束，两个调用之间的命令为将要执行的modification；
		CATransaction可以进行嵌套，但是要保证begin的数量和commit的数量匹配；

透视投影：      在真实世界中,当物体远离我们的时候,由于视角的原因看起来会变小,理论上说远离我们的视图的边要比靠近视角的边跟短,但实际上并没有发生,而我们当前的视角是等距离的;
		也就是在3D变换中任然保持平行，和之前提到的仿射变换类似,在等距投影中，远处的物体和近处的物体保持同样的缩放比例
		为了做一些修正，我们需要引入投影变换（又称作z变换）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：
		CATransform3D的透视效果通过一个矩阵中一个很简单的元素来控制：m34。m34用于按比例缩放X和Y的值来计算到底要离视角多远。
		CATransform3D transform = CATransform3DIdentity;
		transform.m34 = - 1.0 / somedistance;
		transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);
	        self.layerView.layer.transform = transform;
		
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

改变动画的默认行为
	CAAnimation的所有动画的执行都是由CAAction对象去完成，这些对象服从CAAction协议；
	自定义完成的CAAction必须要装配到CALayer上才能够被执行；
	使用CATRansaction来暂时的取消与layer匹配的action：
	[CATransaction begin];
	[CATransaction setValue:(id)kCFBooleanTrue forKey:kCATransactionDisableActions];
	[aLayer removeFromSuperlayer];
	[CATransaction commit];

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

core animation 支持KVO:CGPoint CGSize CALayer CAAnimation 
		比如：transform.tranlation.x   transform.rotate.z ;









