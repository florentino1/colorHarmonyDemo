Quartz 2D时apple原生的二维图像处理引擎，采用的是“画家”的模型：即在一个page上连续的作图，通过搭积木的方式得到最终的视图；需要知道的是一旦一个绘图层完成后，除了在其上覆盖更多的内容，否则无法对一个已完成绘制的layer进行修改，所以绘制的顺序很重要；

图形上下文是一种不透明的数据类型（CGContextRef），它封装了 Quartz 用于将图像绘制到输出设备（如 PDF 文件、位图或显示器上的窗口）的信息。图形上下文中的信息包括图形绘图参数和 page 上的特定于设备的绘画表示。Quartz 中的所有对象都被绘制到或包含在图形上下文中。
图形上下文可以看成是绘制的目标物，只需为同一序列的 Quartz 绘图例程提供不同的图形上下文，就可以将相同的图像绘制到不同的设备上。你不需要执行任何特定于设备的计算，Quartz 会为你执行；

（bitmap graphics context）位图图形上下文允许你在位图中绘制 RGB 颜色、CMYK 颜色或灰度。位图是像素的矩形阵列（或光栅），每个像素代表图像中的一个点。位图图像（Bitmap images）也称为采样图像（sampled images）

在 PDF 文件中，drawing 将作为命令序列保留。PDF 文件和位图之间存在一些显著的差异：
	与位图不同，PDF文件可能包含多个 page。
	从不同设备上的 PDF 文件绘制 page 时，生成的图像将针对该设备的显示特性进行优化。
	PDF 文件本质上是独立于分辨率的，在不牺牲图像细节的情况下，可以无限地增大或减小文件的大小。用户对位图图像的感知质量与要查看位图的设备分辨率有关。

（layer context ）图层上下文（CGLayerRef）是与其他图形上下文关联的屏幕外图形目标，多用于屏幕外绘制。它的设计是为了在将层绘制到创建它的图形上下文时获得最佳性能。对于屏幕外绘制，图层上下文可能比位图图形上下文更好

当前图形状态：current graphics stat,包含了在当前绘制例程中被当做参数的一些特性值，如线宽linewidth、填充色等；对于当前视图而言，当前图形状态决定了在渲染时应该使用的具体细节；
	创建当前图形上下文时，会自动由图形上下文持有一个空的栈用于保存当前图形状态，使用CGContextSaveGstat()函数将当前图形状态压入栈，然后更改当前图形上下文完成绘制后，调用restore方法将之前保存的图形上下文pop出栈；

内存管理：
Quartz 使用 CF内存管理模型，其中对象是引用计数的。创建 Core Foundation 对象时，引用计数为 1。你可以通过调用函数来保留对象来增加引用计数，通过调用函数来释放对象来减少引用计数。当引用计数减少到 0 时，对象被释放。此模型允许对象安全地共享对其他对象的引用。

 需要牢记一些简单的规则：

如果你创建或复制一个对象，你就拥有它，因此你必须释放它。也就是说，一般来说，如果从名称中带有 “Create” 或 “Copy” 字样的函数中获取对象，则必须在处理完该对象后释放该对象。否则，会导致内存泄漏。
如果从名称中不包含单词 “Create” 或 “Copy” 的函数中获取对象，则不拥有对该对象的引用，并且不能释放该对象。该对象将在将来某个时候由其所有者释放。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

图形上下文是UIKIT调用drawRect：方法进行绘制前系统自动配置生成的，在drawrect方法中我们只是使用UIGraphicsGetCurrentContext（）函数获取到这个对象的引用；

位图图形上下文接受指向包含位图存储空间的内存缓冲区的指针。在位图图形上下文中绘制时，缓冲区将更新。释放图形上下文后，将以指定的像素格式完全更新位图。
	位图图形上下文有时用于在离屏绘制，CGLayer 对象（CGLayerRef）已针对离屏绘制进行了优化，因为 Quartz 尽可能在GPU上缓存图层。
	要特别注意的是CGLayer和CALayer的区别；

颜色空间、像素格式、alpha通道预乘：   
	一般而言，每个像素由RGB、alpha这四个分量组成，alpha的值可以预先乘到RGB中直接保存，alpha值的位置在不同像素模式中可以不同；
	bpp: bits per pixel 每像素位，即每个像素点由多少个位来表示；
	bpc: bits per component 每分量位，即每个像素分量由多少个位来表示；
 
	比如：RGB 32 bpp, 8 bpc, kCGImageAlphaPremultipliedLast  表示 bpp为32 ，bpc 为8 即RGB ALPHA四个分量，每个分量由8位表示，该像素模式中每个像素点由32位表示；
	      alpha值为这四个分量中的最后一个（last），且alpha的值以及预乘到RGB中（premutiplied）;

抗锯齿anti-aliasing:   当屏幕显示的分辨率低于人眼识别的分辨率时，视图的边缘就会出现类似锯齿状的边界；为了使视图变得平滑，Quartz在视图的边界部分通过颜色混合的方式将边缘模糊化；
	anti-aliasing是图形上下文的一种，可以调用CGContextSetShouldantiAlias来关闭特定位图的图形上下文；
	调用函数CGContextSetAllowAntialiasing()来控制是否允许对特定图形上下文进行抗锯齿，这种设置不是图形状态的一种，不属于当前图形上下文；

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
___________________________________________________________________________________________________________________________________________________________________________________________________________

渲染的流程、概念、离屏渲染等概念：
	通过draw方法得到的是原始的图元，此时均为CPU进行计算；随后图元信息（定点、线段等信息）被打包发送到GPU ，进入GPU的渲染环节；
	在GPU进行渲染时，首先使用顶点着色器-->形状装配-->几何着色器--->进行光栅化--->片段着色器---->merging混合校验阶段--->将得到的位图放入帧缓冲器暂存以便随后显示设备读取；
	光栅化的主要目的是将完成几何渲染之后的图元信息转化为一系列的像素以便之后在屏幕上进行显示；使用的最简单的方式就是像素中心点划分，如果像素的中心点在几何区域内，则该像素点属于此图元；
	进入片段着色器时将进行pixel的像素处理，即计算每个像素点的颜色信息，最终产生位图文件；
	如果像素的RGB值在片段着色器工作阶段没有预乘，则在混合与测试（merging）阶段会计算每个像素点的alpha值，得到最终的颜色；

屏幕成像和屏幕撕裂、卡顿、掉帧：
	如上所述，GPU渲染完成的位图暂存在帧缓冲器中，等到发送到显示设备上进行显示；
	如果屏幕电子束扫描完成帧缓冲器中的位图信息并显示后，GPU未能及时完成下一帧渲染，即帧缓冲器未能得到更新，此时屏幕将重复显示上一帧的内容；
	    如果在显示上一帧内容的途中，gpu完成了下一帧的内容渲染并缓冲值帧缓冲器，那么此时屏幕上显示的上半部分为上一帧内容，下半部分则为新的帧内容，造成了屏幕撕裂；
	使用垂直同步、双缓冲解决屏幕撕裂：额外添加一个帧缓冲器，在接受到垂直同步信号后，屏幕电子束扫描的帧缓冲需要进行切换，以便显示GPU提前渲染完成的下一帧内容，可理解为两个帧缓冲器的地址指针互相交换
	    垂直同步简单的理解为将帧缓冲器上锁，只有当屏幕电子束扫描完成帧缓冲器中的位图并完成显示后，发出垂直同步信号通知GPU更新帧缓冲器；即屏幕显示的中途不允许更新帧缓冲器；
	    带来的新问题是掉帧：如果在发出垂直同步信号之后，GPU未能完成新一帧的渲染，那么将不会切换到备用缓冲器进行显示，屏幕在本次垂直同步的周期将显示上一帧的内容；即两个垂直同步周期屏幕显示同一帧；
	使用三重缓冲弱化掉帧：再双缓冲机制的基础上再额外添加一个帧缓冲，可以减小掉帧出现的次数；并不能完全解决掉帧的问题；

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

离屏渲染：正常的渲染流程如上所述为：CPU-->GPU--->frameBuffer--->display
	  离屏绘制/渲染的流程为：CPU ---> OffScreen buffer---> framebuffer ---> display
	  
	  可见离屏渲染会导致渲染的过程集中到cpu中消耗额外的CPU时间，并且会消耗额外内存作为缓冲区；此外在offscreen buffer和framebuffer之间的切换消耗也会非常大；
	
	  离屏渲染的使用场景：当中间态需要进行保存已达到某些特殊的效果时需要进行离屏渲染，比如mask蒙版、模糊特效等本身就是用多个渲染结果的叠加来达成的；
			      当渲染完成的结果在特定的时间范围内需要进行复用时，需要进行离屏渲染以提高效率;这是一种编程的主动行为,通过shouldRasterize属性实现；
				  开启光栅化后，会触发离屏渲染，Render Server 会强制将 CALayer 的渲染位图结果 bitmap 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。
				  保存的bitmap 包含layer的subLayer、圆角、阴影、组透明度group opacity等，所以如果layer 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。
				  圆角、阴影、组透明度等会由系统自动触发离屏渲染，那么打开光栅化可以节约第二次及以后的渲染时间。
				  而多层subLayer的情况由于不会自动触发离屏渲染，所以相比之下会多花费第一次离屏渲染的时间，但是可以节约后续的重复渲染的开销。
				  不过使用光栅化的时候需要注意以下几点：
					如果 layer 不能被复用，则没有必要打开光栅化
					如果 layer 不是静态，需要被频繁修改，比如处于动画之中，那么开启离屏渲染反而影响效率
					离屏渲染缓存内容有时间限制，缓存内容 100ms 内如果没有被使用，那么就会被丢弃，无法进行复用
					离屏渲染缓存空间有限，超过 2.5 倍屏幕像素大小的话也会失效，无法复用
	  
	 圆角化的离屏渲染问题；在需要对rectangle进行剪裁以达到圆角化的目的时，通过设置cornerRadius只会将backgroundcolor和border进行圆角化，但是content并不会被剪裁；
			       只有在对layer的masktoBounds属性设置时（或者对应UIView的clipsToBounds），才会将圆角化也应用到content的所有子控件上，此时才会触发离屏渲染；
  			       主要原因是Quartz使用的是画家模型，需要在单个page上一层一层的叠加才能得到最终的图元信息；所以此处的圆角化所触发的离屏渲染问题实际过程应该为：
					cpu分别计算单独的layer层后将其缓冲至offscreen buffer，在所有的layer计算完成之后，再从offscreen buffer中依次提取并分别进行剪裁圆角，最后叠加到page上；

	 重写draw方法会将图层的渲染转移到CPU中完成，并且也会占用额外的内存，但是与标准的离屏渲染概念有区别；
	  			
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

PATH:

可以使用路径将其他对象的绘制限制在路径边界内，从而实际上创建了一个剪切区域；即只有path之内的区域能够显示，而视图之外的区域被剪裁；
用于path绘制的元素有点、线和弧； 系统自动追踪current point作为起始点，绘制线时只需要提供线的endpoint即可；当使用addlines方法时，需要提供点的数组，且数组第一个元素为线的起点；

弧的绘制：需要提供p1、p2和半径，先构造两条切线line1和line2，分别是当前点到p1，p1到p2；也就是说p1是两条切线的交点，p2是圆弧的终点；需要自行计算交点的位置，半圆的话p1不存在；
	  然后寻找这两条线在给定半径下的内切圆的圆弧；再使用一系列的三次贝塞尔曲线对该圆弧进行模拟最后才能够添加到当前路径中；如果当前点不是圆弧的起点，在当前点和起点之间再附加一条直线；

使用线、弧等元素将current point和起点连接的时候实际上并没有关闭路径，必须显式的调用closepath才能够将路径关闭；

椭圆：在CGContextAddEllipsInRect()方法中椭圆是使用rectangle来进行绘制的，椭圆的中心是rect的中心，矩形的长和宽决定了椭圆的长焦短焦的值；如果rect是一个正方形，那么所绘制的椭圆则为一个圆形；

使用CGContextAddRects（）方法绘制矩形时，通过moveto方法确定矩形的起点，需要按照逆时针🔄的方向进行绘制；

在当前图形上下文中，只能同时存在一个path，且此path并不是当前图形状态的一种属性，所以调用CGContextSaveGStat()并不能将其保存；如果当前图形上下文已存在path的情况下调用CGContextBeginPath会将之前的path覆盖；

当需要对图形上下文进行复用时，可以使用CGPathRef类的相关方法获得path的copy，此后对于path的操作将不会再图形上下文中进行，而是直接对保存的path进行直接的修改然后添加到当前图形上下文中；

默认使用非零缠绕原则；

混合模式：Quartz默认使用混合模式blend mode ，计算公式为(alpha * foreground)+(1-alpha)*background; 

剪切区域：剪切区域是当前图形状态的属性之一；默认的大小是当前图形上下文的可视区域；使用非零缠绕原则；

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

颜色和颜色空间

在Quartz中一个颜色代表着一组值，这一组值必须依赖于一个颜色空间才能够表示一个有意义的颜色。
在Quartz中，color除了颜色空间的表示外还必须附加一个alpha值；alpha值是当前图形状态的一个属性值，描述了新绘制好的layer如何被叠加到已经绘制完成的page之上 计算公式在path的混合模式中已经做了说明；

一般意义上需要使用独立于设备的颜色空间才能让颜色在不同设备之上显示保持一致，也就是使用generic 颜色空间，但是IOS设备不提供generic颜色空间，需要使用device colorspace进行代替；

创建独立于设备的颜色空间：CGColorSpaceCreateLab(),CGColorSpaceCreateICCBased(),CGColorSpaceCreateCalibratedRGB()和CGColorSpaceCreateCalibratedGrey();

通用颜色空间(generic color space)将颜色匹配留给系统。
创建独立于设备的通用颜色空间：CGColorSpaceCreateWithName()+kCGColorSpaceGenericGray\kCGColorSpaceGenericRGB\kCGColorSpaceGenericCMYK ；
在iOS中创建与设备相关的通用颜色空间：CGColorSpaceCreateDeviceGray(),CGColorSpaceCreateDeviceRGB(),CGColorSpaceCreateDeviceCMYK() ;,而其他颜色空间的选择将不可使用；

设置填充色：CGContextSetStrokeColorWithColor():---[[UIColor anyColor] setStroke];     CGContextSetFillColorWithColor()---[[UIColor anycolor]setfill];

渲染意图(render intent)指明了Quartz 将如何把来自源颜色空间的颜色映射到图形上下文的目标颜色空间色域中-----完全不知道说的是什么东西。。。


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

translate：有两个空间的概念：user space 和device space,两者之间的映射始终由CTM来完成；w代表x轴上的长度值，h代表y轴上的高度值，可以直接使用；

仿射变换中可以进行求逆，以得到原始的矩阵：CGAffineTransformInver（）；
放射变换可以针对单个点、矩形、或者size结构体进行变换而不是应用于整个图形上下文：CGPointApplyAffineTransform（）CGSizeApplyAffineTransform（)  CGRectApplyAffineTransform（)
判断放射变换是否相同：CGAffineTransformEqueToTransform()
判断所执行的仿射变换是否是恒等变换：CGAffineTransfomIsIdentity();


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

pattern

pattern用于绘制重复图形，将绘制区域分割成单独的cell，在cell内进行绘制，cell的边界并不是绘制的一部分；可以设置相邻的两个cell在x，y方向上的距离；
pattern绘制中cell需要一个特定的rect，即cell中的内容完全在此rect中进行构建，构建完成后，系统将重复调用此cell的绘制方法对其他cell进行绘制；
pattern在rect中拥有一个完全独立于CTM的坐标系统，同样也是LLO的原点模式；

颜色固有的pattern cell 和非颜色固有的pattern cell：对于颜色固有的patter cell而言，cell的颜色作为创建它的一个固有过程，其不能被改变；

tiling：即pattern 与设备显示进行的协调，pattern cell在实际设备上进行显示时可能会存在一定的不匹配的情况，此时需要作出一定的牺牲去适配
	no distortion：以稍微调整pattern cell之间的间距为代价，但不超过一个设备像素， 这被称为无失真。	
	constant spacing with minimal distortion：以稍微扭曲pattern cell为代价，但不超过一个设备像素,这被称为具有最小失真的恒定间距。
	constant spacing:尽可能多地扭曲pattern cell为代价以获得快速匹配,这称为恒定间距。

绘制pattern的步骤;
1、自定义一个回调函数；需要在回调函数中明确定义cell的尺寸信息；如果在回调函数中使用了setcolor等相关函数去绘制cell，那么将创建一个colored cell；
   需要在page的图图形上下文中创建一个CGColorSpaceCreatePattern(NULL),然后用null去填充page的colorspace才能够正确显示cell中的颜色；

2、创建pattern的颜色空间，需要以当前设备颜色空间作为基础：//此处与setcolor 和填充color相类似；
   设置colored cell的color space，在此之前需要保存当前图形状态到栈中，绘制结束后弹出;
   CGColorSpaceRef patternSpace;
   patternSpace = CGColorSpaceCreatePattern (NULL); 
   CGContextSetFillColorSpace (myContext, patternSpace);    
   CGColorSpaceRelease (patternSpace);

   设置非colored cell的color space：
	获取基础颜色空间：只能获取当前设备颜色空间：CGColorSpaceCreateDeviceRGB();
	将得到的基础颜色空间创建pattern space颜色空间：CGColorSpaceCreatePattern();
	将得到的pattern space设置绘制区域的填充、描边：
	释放pattern space和基础颜色空间；

3、创建一个pattern对象：CGPatternRef pattern=CGPatternCreate();
	   
4、设置填充、描边、alpha值到当前图形上下文：CGContextSetFill/StrokePattern()；
5、使用当前图形上下文对绘制区域进行绘制：CGContextFill/StrokeRect();
6、释放创建的pattern对象，从栈中弹出当前图形状态；

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

shadow 

shadow 有三个特征值：x-offset y-offset 和blur value （模糊值决定了shadow的边界是清晰的还是发散的，用于模拟强光线和弱光线）；
shadow是当前图形状态的一个属性，绘制阴影时，系统使用当前设备RGB颜色空间并且将颜色设为黑色，即使用（0，0，0，1.0/3.0）进行绘制；
可以绘制带有颜色的阴影，使用CG绘制阴影时并不会导致离屏渲染的发生，使用CALayer绘制阴影时才会导致离屏渲染的产生；


transparancy layer：透明层
将多个视图内容组合到一起形成一个可以视为一体的内容视图；
Quartz在每一个图形上下文中都维护一个栈用于保存transparency layer，transparency layer对象可以进行嵌套，但是不能被独立操作；

通过调用函数 CGContextBeginTransparencyLayer ()来表示透明层的开始，该函数将图形上下文和 CFDictionary 对象作为参数。
使用字典可以提供可选项来指定有关图层的附加信息，但由于 Quartz 2D API 尚未使用该字典，因此应该传递 NULL到字典。 
在此调用之后，除了 alpha（设置为 1）、阴影（关闭）、混合模式（设置为正常）和其他影响最终合成的参数外，图形状态参数保持不变。

开始绘制透明图层后，将要在该图层中显示的任何视图内容绘制到此透明图层中，此透明图层被视为是与上下文分开的一个缓冲区。

需要注意的是shadow 与 transparency layer的设置相对位置：在设置shadow后开始transparency layer的绘制，才会使得透明层对象显示一个阴影；

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

位图image与image mask

位图图像和image mask对象在Quartz中的back对象都是CGImageRef；

bitmap image 指的是在一个特定分辨率下的像素点的数组；jpg 、PNG都是使用的bitmap image；

创建CGimage对象：
	1、CGImageCreate();比较复杂
	2、CGImageSourceCreateFromURL（）：创建一个imagesource，在imagesource中调用CGImageSourceCreateImageAtIndex();创建imagesource中的特定index的图像；
	3、从当前位图图形上下文中创建：CGBitMapContextCreateImage()，此函数返回的图像是写时复制的；
GCImage 对象是immutable，可以创建略缩图：thumbnail；最终都是调用CGContextDrawImage（）绘制到当前图形上下文中；

创建截图：CGImageCreateWithImageInRect();
	该方法返回时，产生的截图对象会持有原有的image对象，所以调用此方法产生截图后需要调用cfrelease方法释放原有的image对象；
	

创建一个image mask
	原始图的alpha值与mask值的差值，表示原始图可以最终绘制的alpha值；
	imag mask在每一个颜色组分上有不同的位数：1、2、4、8;
	对于1位掩模，样本值1 就代表禁用当前的填充颜色，0 代表被绘制在上下文时代表的颜色。对于2，4，或者8位掩模代表灰度值，每个组分映射到范围0 ~1
	
	使用CGImageMaskCreate()方法生成的mask image 和使用CGImageCreateForm...()方法生成的image mask ，在应用与CGImageCreateWithMask()函数时，呈现的效果完全相反；

	使用特定的色块作为一个image的mask image 可以将image中对应的颜色去除，去除的程度视mask image色块的alpha值而定：使用CGImageCreateWithMaskingColors（）函数；
	在颜色分量数组中的元素的数目必须等于图像的颜色空间的颜色分量的两倍。对于颜色空间中的每个颜色组件，提供一个最小值和一个指定颜色的范围的最值。如果只是掩盖一个颜色，设置最小值等于最大值；

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
**********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________

CGLayer

CGLayer 对象与透明层 transparency layer对象相类似 都可以作为cgpath等绘制内容的中间层过程，通过另存到buffer中的方式可以在随后的实现中方便进行调用；
但是如果直接使用cgcontext的函数进行绘制，那么将不存在以上说明的类似的中间过程，而是直接绘制到当前图形上下文中；

Quartz可以自动对相应图形上下文的CGLayer对象进行缓存，其在离屏渲染中重用的速度要比使用位图对象更快；
创建需要复用的layer对象;CGLayerCreateWithContext: ，此处需要限定layer层的尺寸信息，即该函数的第二个参数；该函数的第三个参数现在尚未使用，传入NULL即可；
在开始对保存的layer对象之前自定义绘制：如颜色填充，path绘制之前，需要获得创建该layer的图像上下文：CGLayerGetContext（）；此处得到的是在上一步中已经限定好尺寸信息的图形上下文；
自定义layer层：在上一步中得到图形上下文中绘制路径、填充等，调用相关的fill stroke函数等；
开始使用layer层对象进行绘制的方法：CGContextDrawLayerInRect: CGContextDrawAtPoint:  ；此步骤中使用的context并非上面2、3步得到的限定尺寸的图形上下文，而是第一步传入的原始图形上下文；
	如果需要使用layer层对象在原始图形上下文中进行重复绘制，那么需要使用CTM进行原始图形上下文的原点坐标的平移；

如果创建layer层对象的图像上下文是一个window的图像上下文，那么Quartz就会尽可能的将该layer层对象缓存在GPU之中；

注意CGLayer与CALayer是不用作用的数据类型；















