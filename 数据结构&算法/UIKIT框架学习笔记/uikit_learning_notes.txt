APP and Environment

Ukit在启动 阶段的作用：
	程序开始启动后，UIKIT会自动创建UIApplication 对象和app delegate，然后UIKIT会启动app的主循环 runloop；
生命周期方法：application:willFinishLaunchingWithOptions: 在程序启动完成launch、main storyboard\nib文件被load但是视图未显示时进行调用，此时程序处于inactive进行调用；
	      application:didFinishLaunchingWithOptions: 在程序进入active但是还没有显示更多的UI时进行调用，是进行初始化的最后的机会,在此函数返回后uikit才会显示用户界面
程序的所有状态的变化都会导致UIKIT向应用代理对象（UIApplicationDelegate/UISceneDelegate）发出状态变化的notification

程序在从inactive状态完成launch之后会立即变成active状态，但是此时app的UI界面尚未在主屏幕上显示，此时可以调用applicationDidBecomeActive:方法进行界面UI的更新，已经数据的更新
	foreground inactive--->foreground active--->foreground inactive--->backgound--->suspended--->terminal
程序进入前台：当程序从applicationDidBecomeActive:方法中返回后，uikit将会将Window显示在主屏幕上并加载相关联的viewcontroller提醒其将要在主屏幕进行显示，此时可以调用viewcontroller的vieWillAppear：方法对用户界面
	对用户的UI界面进行必要更新，当viewController显示完毕后会调用viewDidApear：方法完成之后的数据配置；（特别注意的是在viewWillAppear：方法中不要改变将要加载的viewcontroller）
程序进入后台时，不可以占用系统硬件否则会导致程序被系统停止；此外在进入后台时UIKIT会生成进入后台时的snapshot以便在任务管理器中显示，或者在该程序重新进入foreground时加载；

UIApplication对象：程序执行主函数时会执行UIApplicationMain（）函数(此函数不会返回任何值),此函数会创建一个UIApplication的单例对象，此单例对象会将UIControl类及其子类的控制信息转发到合适的目标对象---即响应者链
		   UIApplication对象维护了一个UIWindow的列表可用于遍历所有的UIView的对象
		   此对象拥有一个application代理对象，程序状态发生变化时，此对象会通知其代理对象appdelegate做出相应的反应；
		   注册、取消远程通知；
		   获取应用程序的当前状态---UIApplicationStat；
		   管理app是否可以在后台运行，在后台进行状态的改变、通知以及数据获取
		   管理app是否可以通过URL进行界面跳转，比如打开系统设置中属于本app的设置页
		   其他事件管理 如外观、icon等等；
AppDelegate对象：每一个app都会拥有一个代理对象，一是用来对app的状态变化做出反应，二是当系统事件到达时，事件会被路由到代理对象进行处理；
		 此对象遵循UIApplicationDelegate代理协议，该协议定义了一系列的方法，包括之前提到的声明周期方法和相对应的状态发生变化时的通知等；
UIDevice：可以获取当前设备的相关信息元素，例如设备朝向等信息；前提：使用beginGeneratingDeviceorientationNotifications:方法通知此设备当设备的朝向发生变化时产生相对应的\
	      UIDeviceOrientationChangeNotifacation通知，相对应的当不需要设备朝向的信息时需要调用endGeneratingDeviceOrientationNotification：方法以通知设备停止通知；
	  相类似的还可以要求设备产生类似于电池batteryState、proximityStat的通知，相对应的是电池的状态和用户是否手持设备并接近脸部；查看document
	  需要进行确定是在什么时候注册相应的系统通知和在什么时候注销相应的系统通知：最好是在launch阶段进行注册，在terminate时注销；且注销并不会影响其他应用程序对于通知的接受，\
	  而且一般意义上程序在进入后台状态时还是能够接受到系统的设备姿态调整的通知；
UIStatusBarManager:这个类是在ios13.0之后才出现的，可以用来管理每个UIWindowScene下的状态栏是否应该隐藏，具体是在UIviewcontroller中对其preferStatusBarHidden属性进行设置；\
	  还可以为该Viewcontroller的子视图的statusbar进行设置，使用childviewcontrollerstausbarhidden属性进行设置，具体的在UIViewCtroller的介绍里
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
********************************************************************************************************************************************************************************************************
________________________________________________________________________________________________________________________________________________________________________________________________________

USER INTERFACE

继承树：NSObject->UIResponder->UIView

当两个视图之间有父子关系时，如果子视图的可见区域超出了父视图的范围，默认的情况是不对子视图超出父视图区域的部分做剪裁，可以设置父视图的clipsToBounds属性将其修改为true；
***frame 和bounds属性的区别于联系***
      frame:首先是frame的概念表示的是一个视图的左上角的位置坐标x，y在以其父视图左上角坐标值为原点的坐标体系中的相对位置，请注意的是父视图左上角的点虽然为原点，但是其坐标值并不一定(0,0)，除非其为根view；
      bounds:对于bounds的概念理解应该要以本视图为参考系，本视图左上角的点作为坐标原点；当没有显式的对原点的值进行任何自定义设置时，其左上角点坐标(x,y)的值为(0,0);
	     如果对本视图左上角原点坐标的值进行了显式设定，则本视图的坐标原点的值将不再是(0,0)，而是变成了显式设定的坐标值(x,y)。
	     所以在以本视图作为父视图添加子视图时，子视图在父视图（即本视图）中的位置将以显式设定的坐标值(x,y)作为起始点;
所以对于一个视图而言，其左上角点的坐标有双重的含义：在以其父视图为参考系时，左上角点坐标为本视图在其父视图中的相对位置，即frame；
					            在以本视图为参考系时，左上角点的坐标默认情况下为(0,0)，即bounds；
subViews数组的排序：addSubView:方法将一个视图添加在其父视图的子视图数组尾部；此外还可通过insert方法或则是exchange方法记性灵活性比较大的子视图插入；
		    另外通过bringsubviewtofront:或者sendsubviewtoback:方法可以将摸个特定的视图移动到数组的头部或是尾部；
视图绘制：使用UIKIT或是CG进行定义的视图，系统会在视图全部或是部分出现的时候调用该视图的drawRect:方法进行绘制，并加入到当前的graphics图形上下文中;
	  当本视图的内容发生变化时需要显式的通知系统进行视图的重绘，系统会在下一个绘制周期将本视图进行重绘，调用setNeedsDisplay：系列方法；
动画：在UIView及其子类中，能够进行动画化的属性有frame bounds center transform alpha backgroundcolor contentStretch
tintColor：一个奇怪的属性，每一个UIView都有，如果一个视图没有显式的设定其tintColor，则他会默认使用其父视图的tintColor进行内容的显示，
	   如果根视图也没有显式使用非系统默认的tintColor，就会使用系统的默认值也就是平常见到的蓝色，且这个tintColor会沿着继承树向下进行传播，知道某个子视图设定了其tintColor；
	   也就是说tintColor这个属性是为了子视图设计使用的，其颜色对本视图的内容呈现没有影响；
	   一个视图如果未显式设定tintColor则使用从父视图传递下来的tintColor；如果一个视图显式设定了一个非系统默认的tintColor，则将此tintColor从自身向自身的子视图方向进行传播，但是本视图颜色不变化；
maskView：表示的含义是对视图进行遮罩，有两个基本的视图：本视图view1，遮罩视图 maskView；view1需要添加到父视图中，但是maskview不能作为子视图添加给view1，而是作为view1的遮罩视图，调用view1.maskview方法
	  当对一个视图进行遮罩的时候，根据遮罩视图maskview的alpha值的不同而显示的效果不同，maskview的alpha值为1，表示作用于view1上的maskview对于view1全透明，呈现的颜色与没有进行maskview遮罩时相同；
	  当对一个视图进行遮罩时，只显示遮罩视图maskview与view1重合的部分，其他部分不显示；
	  maskview不作为view1的子视图进行添加，可以理解为maskview是嵌在了view1之上；
CALayer：每一个view都有一个CALayer对象作为支撑，所以每一个view的layClass属性永远不可能为nil；view只是这个CALayer对象的代理；
	 layerClass是针对一个视图的根视图类而言的，对于根视图才有layerClass这个概念，子视图需要调用其属性layer方法获得其对应的层对象；
layout margins表示的是视图的安全边距，在一个视图周围需要留白的部分，这一区域没有任何可视的元素，会作为视图约束的一部分加入layout的计算，使用UIEdgeInsert：来设置；
        directionalLayoutMargins：属性值表示一个视图的默认margins，通常四面的margins都为8个点，如果是视图控制器的根视图，此默认值则是该设备默认的最小的安全区域的距离值；
                                  此值受到系统安全区域的margins值和父视图的margins值的影响；如果将本视图的preservesSuperViewLayoutMargins属性设置为真，当本视图的内容与父视图的margins部分有重叠时会自动\
                                  调整本视图的margins值（增大）；
UILayoutGuide：是一个虚拟的视图，不会产生视图的实体，而是以一个矩形框的占位符的方式存在于图层中用来相应自动布局AZ的计算，不接受事件路由，不可见
 	       safeAreaLayoutGuide是UILayoutGuide的子类，对应于视图控制器本身而言的一个只读属性，可以保证来自父类或是其他的尺寸变化不会影响到其视图或是子视图的内容呈现，即不会遮挡视图；
				  此时布局的方式就不是针对于view的frame本身，而是相对于view的safeArea进行布局；
	       safeAreaInsets这个属性在官方文档里描述的是每一个view都具备的一个可以安全显示其内容及子视图内容的一个约束参考，但是在视图未加载或是视图未出现在屏幕上时保持其值为0；
	       此处要参考viewController的声明周期方法进行设置（viewDidAppear:或者viewSafeAreaDidChange:），否则获取到的insets是0，而无法正确产生约束；
	       所以总体来说要产生相对于safeArea的约束,需要在（viewDidAppear:或者viewSafeAreaDidChange:）方法中获取到safeAreaInsets的有意义的值；
	       第二就是在viewDidLoad:方法中使用safeAreaLayoutGuide属性获得；
UIview的声明周期方法：
	loadView:---> viewDidLoad:--->viewWillAppear:--->viewWillLayoutSubview:--->viewDidLayoutSubview:--->viewDidAppear:--->viewWillDisappear:--->viewDidDisappear:

约束：约束只能作用于视图本身及其所属的子视图，如子视图依赖于父视图的约束应该被添加到父视图，子视图本身的固定约束添加到子视图本身，使用约束的.active属性即可；
      产生约束的方式：通过NSLayoutConstraint对象使用NSLayoutAtrribute的方式生成；
		      直接使用NSLayoutAnchor的方式生成；
		      使用UILayoutGuide对象创建占位视图，其直接依赖于NSLayoutGuide进行视图约束；使用时需要新建UILayoutGuide对象，并将此对象使用addlayoutguide添加到当前视图；
      对齐：使用的是对齐矩形--alignment rectangle的概念而不是使用一个视图控件本身的frame；
	    在使用alignmentrectangle 这个概念时需要使用的是alignmentRectInsets，同safeareaLayoutInsets类似，都是UIEdgeInsets结构体；alignmentRectInsets不仅包含内容视图的frame，还包括了对视图本身做的装饰，比如阴影等元素在内；
	    在进行自定义视图的绘制时，可以使用alignmentRectInsets来返回，否则默认条件下此集为0；
      更新约束：如果是比较简单的约束的更新，直接在需要更新的地方改变空间的尺寸信息然后直接调用updateConstraints：方法即可；
		如果需要改变的尺寸信息很多，可以在需要改变尺寸信息的地方调用setneedsUpdateConstraints:方法告知系统约束需要进行更新
		系统调用updateConstraintsIfNeed：方法对对象视图及其子视图进行检查，如果需要进行约束的更新则在layout之前调用updateConstraints：方法进行更新；
		一组对应的方法：setNeedsUpdateConstraints: updateConstraints;
				setNeedsLayout   layoutIfNeeded   
      内容显示：一个视图的内容显示需要对其自身的尺寸变化进行适配，适配的原则就是UIViewContentMode，可以保持/改变自身的纵横比来填充、拉伸或是剪裁超出边界的视图；
      sizeToFit：方法是一个视图需要进行约束优化以便其包含自身所有子视图时使用的方法，但是如果这个视图没有父视图，其有可能会被拉伸到整个screen范围，所以在对某个视图使用此方法前确保其父视图存在；
                 此方法不应该被重写，如果有需要可以调用sizeThatFit：方法，其返回的结果会被sizeToFit所使用；
      translatesAutoresizingMaskIntoConstraints属性：该属性值默认为YES，表示的是系统会自动根据autoresizing mask来对创建一组基于视图frame的约束，该约束已经完备，所以你无法添加额外的约束否则会冲突；
		在使用IB进行视图的配置的时候，IB会自动将此属性的值配置为NO；
		在使用代码+frame进行布局时，创建的也是基于静态的frame的布局，不能够添加额外的约束来改变视图的位置和大小；
		在使用代码和Auto Layout进行布局时，需要将该属性的值设为NO，然后自定义一组完备的、无歧义的约束即可；
绘制：drawing： 方法使用传入的rectangle进行视图的绘制，默认的实现里为空；当视图第一次调用draw：方法时，会绘制其所有可见区域的bounds，在随后的调用里可能只会绘制需要进行modify的一部分；
		如果只对视图显示背景颜色，或是直接使用view的层对象layer就可以完成的内容绘制则不需要对draw：方法进行重写；
		如果子类直接继承UIView，在draw：方法中则不需要调用super方法；如果是继承自其它视图类，需要调用super方法；
		在程序实现中不要直接调用draw：方法，视图第一次呈现或是后续需要update时系统会自动调用；
命中测试：事件会沿着继承树遍历根视图的所有子视图，来检查点击的点是否在任何一个子视图的范围内；如果pointInside:方法返回yes，将会沿着继承树找到最后一个能够使pointInside方法返回yes的视图；
	  如果一个视图pointinside方法返回no，则该视图及其子视图都将被忽略，且hittest方法返回nil；hittest方法会忽略隐藏的视图、alpha值低于0.01的视图和不能够响应用户点击动作的视图空间；
	  当子视图显示的范围超过父视图时，如果父视图的pointinside方法返回NO，即便点击的point在子视图显示的范围内，子视图的hittest方法仍然不会被调用；
事件传递：触摸事件-->UIAPPlication-->UIWindow-->UIView-->遍历UIWindow的视图对象（后续遍历，最后加入视图的控件最先遍历，使用的是一个view的subViews数组）
响应者链：只能UIResponder的子类才能够响应触摸事件：hittest_view控件响应事件，如果有父视图则下一个响应对象是父视图;没有父视图则下一个响应对象是viewController，一直将下一个响应对象传递到UIApplication->nil;
事件分发：IOS在处理事件的时候回使用sendEvent：方法将事件传递给第一响应者：firstResponder，如果第一响应者没有处理对象，则传递给当前responder的nextResponder；
具体流程：当一个触摸发生时，系统调用命中测试机制找到触摸发生点的视图---hittest_view，并将该view作为firstResponder尝试让其去处理事件，否则事件沿着响应者链进行传递，直到被丢弃；
扩大一个按钮的触摸范围：使用CGRectInset()方法来构建一个新的rectangle，该方法含有三个参数，后两个参数为在前一个参数的各个方向上增加的值，扩大则为负值；然后使用CGRectContentPoints()判断点是否在rectangle内
忽略当前视图的响应：如果需要屏蔽当前视图的响应，则需要调用其父类的命中测试方法遍历视图继承树，返回的hittest_view如果是自身则返回nil；---各种应用本质上都是视图的重定向；

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
********************************************************************************************************************************************************************************************************
________________________________________________________________________________________________________________________________________________________________________________________________________

      
UITableView

一个UItableView的基本元素：tableviewController，tableView，delegate，DataSource，tableViewCell，row，section，header ，footer；

UITableview外观配置：
	继承自UIScrollView
	使用stateRestoration来储存tableViewCell当前被选中的状态；
	tableView的三种style：UITableViewStyleGrouped：UITableViewStyleInsetGrouped： UITableViewStylePlain：
	backgroundView：默认为nil，设定之后不会随view的滚动而产生变化；
	tableheaderView：整个tableview的头部视图，与为每个节分配的headerView是两个东西；
	tableFooterView：整个tableView的脚部视图，与为每个节分配的footerview是两个东西；
DataSource对象：UITableViewController的dataSource对象是weak型的，必须符合数据源协议；
prefetchDataSource对象作为DataSource对象到tableViewcell的缓冲，在下一个绘制周期时使用prefetchDataSource的对象内容进行显示；

cell--可重用cell：
	使用registerNib: forCellReuseIdentifier: 告知系统使用identifier的nib文件创建一个cell并以此作为模板；如果需要使用另一类型的cell，可以将此identifier对应的nib重置为nil，然后调用此方法注册新的nib；
	使用registerClass:forCellReuseIdentifier:此方法桶以上方法相类似，告知创建cell所使用的nib或者是class，但是如果identifier相同，则会覆盖之前的设置；
		使用注册class的方法注册cell时，需要在-(instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier方法中完成自定义的配置，包括cell元素的初始化；
	dequeueReusableCellWithIdentifier:tableView维护了一个能够重复使用的cell的链表或是队列，如果存在一个identifier指定的cell时，tableView使用它装载特定数据，没有可用的cell会先创建一个然后再进行复用；
		如果当前没有可以复用的cell，而且并没有用register方法进行注册，那么此方法会返回nil；如果当前存在一个使用identifier标识的cell，那么此方法会返回一个调用过prepareForReuse：方法的cell供代理使用；
	dequeueReusableCellWithIdentifier:ForIndexPath： 与上上述的方法类似，但是返回的cell将用于指定的indexpath；
	
	rowheight属性设定了每个cell的高度值，默认是来自UITableViewAutomaticDimension的默认值，会根据cell的内容自动计算一个cell的高度；如果复写了tableView:heithForRowAtIndexPath:方法则会忽略rowHeight属性
		，然后为每一个cell调用该协议方法，包括离屏没有进行显示的cell，造成巨大的性能损失；
	estimatedRowheight属性：一个非负的对cell高度的估值，默认是使用的UITableViewAutomaticDimension属性的值，使用预估的高度可以将大量cell的载入性能提高，如果不想使用此兴致，将该属性值设为0；
	insetsContentViewsToSafeArea：布尔属性，指明tableView是否应该将内容显示在安全区之内；




section header footer---可重用的节头部和节脚部
	- registerNib:forHeaderFooterViewReuseIdentifier:
	- registerClass:forHeaderFooterViewReuseIdentifier:
	- dequeueReusableHeaderFooterViewWithIdentifier:
	
	sectionHeaderHeight、sectionFooterHeight、estimatedHeaderHeight、estimatedFooterHeight；

两个重要的协议---数据源协议和代理协议








































