每一个视图UIView都由一个CALayer对象支持渲染、动画等；

bar button item并不是一个view ，所以不能够获取layer层对象；其继承树是NSObject->UIBarItem->UIBarButtonItem .

视图的绘制代码draw：方法需要尽量少的被调用，已经绘制完成的视图会被缓存供修改或是重用，以减少资源的消耗；

UIView类使用按需绘制的模型进行视图的绘制更新；当视图第一次出现时，系统调用drawing方法对视图进行绘制；此后系统会保存此时的界面snapshot，如果此后界面不发生变化则相关对象的draw：方法将不会再被调用；
当view的内容发生变化时会自动通知app view需要被更新，然后重复以上的过程；

每个视图都有一个内容模式（content mode），用于控制视图如何回收其内容以响应视图几何形状的变化以及是否回收其内容：默认是UIViewContentScaleToFill，即视图不保持纵横比的情况下进行拉伸；
可以设置视图的可伸缩性（content stretch），0.0到1.0之间的范围，可用于维度尺寸自动变化的视图，如label、button等；
contentMode和contentStretch 两个属性之间可以互相影响，只用contentMode这职位scale属性时，contentStretch属性的可伸缩区域才不会被忽略；

每一个UIWindow都有一个level的概念，normal level的UIWindow将正常对App的内容进行显示，high level的UIWindow对象将会浮在正常视图的上方，比如电话提醒，alert等；
对于有多个UIWindow的app，同一时间只有一个keyWindow，用于接收与键盘相关、与触摸无关、不与坐标值绑定的事件；此外触摸事件将会传递到发生触摸事件的窗口，与窗口本身是否是keywindow无关；

tag:为视图控制器、视图控件设置tag标签以便需要时可以快速获得视图对象；tag使用深度优先的查找，如果从根视图调用viewWithTag：方法会遍历说有视图空间；从某一个特定的视图进行查找则只会遍历其子视图；

如果以编程方式构建视图，则将视图创建代码放在视图控制器的 loadView 方法中；无论以编程方式创建视图还是从 nib 文件加载它们，都可以在 viewDidLoad 方法中包含额外的视图配置代码；

当子视图被添加到父视图时，UIKIt会向子视图和父视图双方均发送通知，调用回调方法：willmovetosuperview   willmovetowindow   willremovesubview等等；可以重写这些方法以拦截通知；
当前显示在屏幕上的所有视图都有一个window属性，视图继承树的根视图就是window对象，其父视图为nil；

将视图隐藏时可以设置其hidden属性，或是将其alpha值设为0.0；隐藏的视图不接受触摸事件，但是还会会响应系统通知，如traits变化、尺寸变化等；
如果某个将要隐藏的控件现当下为firstresponder时，系统并不会改变其firstresponder的状态，需要显示的强制resignfirstresponder；

UIView 的 transform 属性包含一个 CGAffineTransform 结构，其中包含要应用的转换。 默认情况下，此属性设置为恒等变换，不会修改视图的外观

坐标系相对坐标值的转换：rect的转换与点坐标的转换，convertpoint: fromview:   convertrect: fromview:  convertpoint: toview: convertpoint: fromview:
			另外还可以相对于window进行转换，与上述类似;

当一个视图进行旋转时，进行旋转的视图作为子视图加入到能够完全包含旋转视图的最小父视图内，并重新计算frame等属性值；

当更改视图的大小时,任何子视图的位置和大小通常需要更改以适应其父视图的新尺寸;父视图的autoresizesSubviews属性决定子视图是否完全调整
如果此属性设置为YES，则视图使用每个子视图的autoresizingMask属性来确定如何调整子视图的大小和位置。任何子视图的大小更改都会为其嵌入的子视图触发类似的布局调整。
autoresizemask 是一组枚举常量，默认是UIViewautoRisizingNone 即不会自动调整子视图的大小和位置;除此之外还有UIViewAutoResizingFlexibleLeft等可以限定某个方向的尺寸自动调整；

确保代码对状态栏高度的变化做出适当的响应；当通话处于活动状态时，状态栏的高度会增大；当用户结束通话时，状态栏的尺寸会减小；可以使用safeArealayoutGuide等属性值来保证；

UIGraphicsGetCurrentContext()函数获得当下的图形上下文，在此时的图形上下文中去做draw：，其只存在于每一次draw：方法调用期间，不能使用缓存的图形上下文用于视图的重绘；
如果需要重绘的视图opaque属性为yes，即视图完全不透明时，UIKIt将不会马上对被opaque视图遮蔽的视图进行绘制，以减小工作量；


animation: UIView能够动画化的属性有7项：frame bounds center alpha contentstretch backgroudcolor transform；不是UIView类的对象需要单独使用CA去实现动画；
	   UIView中使用动画的主要方法为animateWithDuration：类的方法，根据参数的不同可以控制不同的动画形式；此类方法均为类方法，所以无法绑定到某个特定视图；
	   通过反复调用类方法：setAnimateEnabled: 来在特定的过程中禁止动画，在特定的过程中启用动画；
	   嵌套的动画可以通过配置不同的option值来自定义自身的动画行为，嵌套的动画与父动画同时启动，继承父动画的持续时间、curve等，也可以自行配置；
	   使用UIViewAnimationOptionRepeat属性设置重复动画时，如果未显式的设置需要执行重复动画的次数则动画永远也不会结束，即永远也无法调用completion模块；需要使用setAnimationRepeatCount：方法；
	   视图的转换只涉及到视图的继承树内部本身，在视图转换的前后，视图控制器的状态保持不变；而视图控制器参与的转换会导致视图控制器本身的一个替代，需要导航栈的参与，视图控制器的状态发生变化；
	   transitionWithView:duration:options:animations:completion:可以完成视图之间的转化，self.view作为容器视图负责变换的实现；
	   	   
	   
