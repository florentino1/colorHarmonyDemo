blocks: 匿名函数，无函数的名称；可以捕获自动变量的值；
	block实际上是oc的对象；
	编译器在将block进行翻译时，会自动生成多个结构体：将block的实现部分作为一个函数并将此函数的指针赋值给block结构体中funcPtr指针变量；
	block对象拥有一个isa指针，指明了block对象的类型；
      	struct_block_impl{
		void * isa;
		int flags;
		int reserved;
		void *funcptr; }

	构造一个block实现的函数：static void_block_func_0()
	构造一个block实例的描述对象：struct_block_desc_0,并将其取别名为_block_desc_0_DATA;
	构造一个block的实例：struct _block_impl_0,包含了impl和desc的实例结构体，以及初始化函数_main_block_impl_0()
		_mian_block_impl_0()函数可以将impl实例结构体完成初始化：包括isa，funcptr等；
	在使用block的主函数中将需要block实现的函数func，和函数的描述desc作为函数_mian_block_impl_0的参数完成block实例struct _block_impl_0结构体的初始化，并将_main_block_impl_0()函数地址赋值给
		某个函数指针blk，在主函数中使用blk的funcptr指针完成func函数的调用；

	block捕获自动变量：block会捕获在block中使用的自动变量；此时block的类型定义不变，即struct _block_impl {}并为发生变化，因为这这是声明；
		但是block实例对象却发生了变化：struct _block_impl_0{}结构体在struct _block_impl{}的基础上，新添加了在block中需要使用到的自动变量；
		同时block实例的构造函数_main_block_impl_0{}同样更新了参数列表，并对block实例对象完成初始化。对外的最终效果就是block赋值了自动变量的值到自身的结构体中进行了保存；

	block不能捕获c的数组，只能捕获c数组的指针：由上可得，block会在自身的结构体内声明一个c的数组准备在构造函数初始化时对外部数组进行赋值，但是c不允许数组之间的相互赋值；
	block保存自动变量时使用直接赋值的方式；保存静态局部变量时，在block结构体中保存指向该静态局部变量的指针，func调用时使用指针访问该变量；不会在结构体中保存全局变量的值或者是指针地址；

__block储存域类说明符
	声明了__block之后的自动变量，在编译时会被自动转化为__block_byref_val_0{}结构体的实例对象，该结构体的成员变量val为原自动变量的值；
	struct __block_byref_val_0{
		void *__isa;
		__block_byref_val_0 *__forwarding;	//这个_forwarding指针指向的地址取决于block当前是否被赋值到堆中；
		int _flags;
		int _size;
		int val;	}
	此后在block结构体实例中也会添加相应的struct__block_byref_val_0 结构体类型的指针，然后在block的构造初始化函数中完成初始化；
	因为在block结构体实例中添加的是__block 型自动变量的结构体的指针，所以在block中对于自动变量的修改对于其他使用该自动变量的block是可见的；

	
block储存域：
	在此前说到block的结构体实例中有一个isa指针，该指针的值决定了block的储存域，共有三种类型：
	_NSConcreteStackBlock--block结构体的实例对象储存在栈区
	_NSConcreteGlobalBlock--block结构体的实例对象在.data区
	_NSConcreteMallocBlock--block的结构体实例对象在对区；
	
	将block声明在全局变量区，且不适用自动变量可将block类型设置为_NSConcreteGlobalBlock:
		在.data区域保存的block结构体中无法保存自动变量，所以也就不存在对自动变量进行捕获的说法，所以该结构体或者说该block并不关心运行时的状态；
	
	将栈上的block结构体实例复制到堆中，将其转变为_NSConcreteMallocBlock型，可以在两者超出作用域时使用指针地址访问正确的结构；
		在将栈上的block复制到堆中时，编译器大概率会自动判断然后进行代码生成：比如将block作为函数的返回值时，将栈中的block复制到堆上并返回，原栈上的block因为函数结束超出作用域而被销毁；
		此外使用GCD时、或者带有usingBlock的标识参数时不需要手动进行block的复制；
		其他情况下可以直接对block对象或者__block类型自动变量使用copy方法；
		对.data区域的block使用copy方法将什么也不发生；对stack区域的block使用copy将其复制到堆上；对堆区的block使用copy方法将增加其引用计数；
		对堆中的block重复copy操作在arc下不会产生内存泄漏；

	__block型自动变量：当一个block使用一个__block型自动变量时，如果在栈中，两者不是持有与被持有的关系；
			   当栈中使用__block自动变量的block被复制到堆中时，__block自动变量也会被复制到堆中，且block持有该自动变量；
			   如果多个block使用在栈中使用该__block自动变量，那么一旦这些block被复制到堆中后，该__block自动变量的引用计数将会增加；
			   此时如果堆上的block被废弃，那么堆中__block型自动变量会根据其引用计数的值确认自身是否会被释放；
			   
	__block_byref_0类型的结构体重forwarding指针：如果当前__block变量未被赋值到堆中(即block为stack储存)，那么forwarding指针指向位于栈中的自身；
			  如果栈中的__block变量被复制到堆中,那么位于栈中的__block_byref_0中的forwarding指针将指向位于堆中的__block_byref_0结构体；
				而位于堆中的__block_byref_0结构体中forwarding指针指向位于堆中的自身；


以上内容大多数针对的是自动变量（特指标量数据）的捕获，以下内容为oc对象的捕获：
	在编译时，c的结构中不能包含oc的对象，因为编译器并不知道如何管理oc对象的声明周期；
	但是在block中，由oc运行时库支持，可以在c的结构体中使用包含内存管理语义的内容的oc对象；为此，需要在使用block时生成copy和dispose方法，以便完成oc对象的声明周期管理；
       ：__block_impl_0{}结构体实例中包含了oc的对象，struct _block_desc_0{}中添加了copy和dispose函数，并使用其别名为_main_block_copy_0，和_main_block_dispose_o函数；
	在_main_block_copy_0函数中调用_block_object_assign()方法对结构体实例中的oc对象赋值；在_main_block_dispose_0函数中调用_block_object_dispose()函数将block结构体实例中的oc对象销毁； 
	此时结构体声明也会发生相应变化：
	 struct __block_byref_obj_0{
                void *__isa;
                __block_byref_obj_0 *__forwarding;      //这个_forwarding指针指向的地址取决于block当前是否被赋值到堆中；
                int _flags;
                int _size;
		void(*__block_byref_id_object_copy)(void*,void*);
		void(*__block_byref_id_object_dispose)(void*);
		__strong id obj;	}


	不论是自动变量(特指标量数据)被捕获还是oc对象被捕获，在将block保存至堆中时，都需要copy和dispose函数进行这两种对象的内存管理，区别在于传入的函数不同：
	__block自动变量在复制到堆时，copy和dispose函数传入的最后一个参数时BLOCK_FIELD_IS_BYREF；
	oc对象被block捕获并复制到堆中时，copy和dispose函数传入的最后一个参数是BLOCK_FIELD_IS_OBJECT;


	以上block在持有oc对象时，持有的是strong类型的oc对象的指针，如果所持有的oc对象指针为weak型，那么超出作用域后weak指针会被置为nil；
	
	在将块对象赋值给其他变量时，需要关注该变量的储存位置；类的成员变量是储存在.data区的，将stack块赋值给成员变量将导致块被复制到堆中；

	




































