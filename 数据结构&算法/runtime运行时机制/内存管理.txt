ios的内存管理机制：
	ios采用的是引用计数的方式来进行内存管理，当前主要的形式有ARC与MRC；
	需要明确的概念是：ARC完全以MRC作为基础，两者的机制完全相同，ARC只是编译器在合适的位置自动补充内存管理的方法调用；此篇note中要以MRC的理念来理解；

内存管理的基本原则：
	1、对谁持有：可以持有由自己生成的对象，也可以持有非自己生成的对象；
	2、对谁释放：只能对自己持有的对象进行释放；
	3、何时进行释放：当不在需要自己持有的对象时需要释放；
	第一条需要进行区分的概念是怎么样叫做自己生成，怎么样叫做非自己生成：alloc/new/copy/mutableCopy 方法为前缀且严格符合驼峰的方法才能自己生成并持有，此时rc为1；
		但是自动变量需要持有非自己产生的对象时，编译器会在给自动变量赋值之后自动插入一条retain语句，此时rc才为1；
		这两种操作返回的结果都是使rc=1；不能中断得到rc=0且未分配给自动变量的对象；	

考虑运行时对象在堆中的储存结构：
	对象在内存中以块进行储存时可以采用在块头部中内嵌引用计数值的方式保存当前对象被持有的信息；
	对象在内存中储存时还可以将引用计数的值与对象内存块分离，使用单独的散列表(引用计数表)来对每个对象的内存地址和引用计数的值进行保存----apple采用的方式；

基本机制--MRC
	基本方法：retain  release   alloc   dealloc  retaincount autorelease

	MRC中没有引用、强引用、弱引用、引用循环的概念，在思考时一定要排除强弱引用的影响，记得引用计数中的计数即可：即MRC完全通过判断对象rc是否为0来决定是否将对象释放；

	可能的实现细节之alloc：
		alloc-->allocWithZone: --->class_createInstance()-->_class_createInstanceFromZone()-->调用malloc_zone_calloc()或者calloc() （在runtime_new.mm中实现）
	可能实现的细节之retain\release/retaincount	
		通过调用_CFDoExternRefOperation()方法确认需要的枚举命令后来选择具体执行的方法：CFBasicHashGetCountOfKey()、CFBasicHashAddValue()、CFBasicRemoveValue()方法来操作hash表；
	可能实现的细节之autorelease：
		变量超出作用域时会被自动释放；
		将自动释放池组织成一个数组的形式
		无论调用哪一个对象的autorelease方法实际上都是调用的NSObject类的实例方法；
		不能将一个NSAutoReleasePool对象通过其自身的autorelease方法添加到自动释放池中；
		在变量持有一个非自己产生的对象时，该对象实际已经被加入到了自动释放池中：编译器会检查方法名是否已alloc等开始，如果不是将会自动调用autorelease方法注册到自动释放池；
**************************************************************
以上所有方法在ARC的源代码实现中均不可调用，编译器会自动插入；*
**************************************************************

ARC在MRC的基础上新引入的机制：对象所有权
	基本修饰符：_strong _weak _unsafe _unretained  _autoreleasing
	_strong: 是所有id类型和对象类型的默认所有权修饰符；_strong修饰的对象在超出其作用域时，强引用失效，响应对象的referencecount会-1；
		 在使用_strong声明一个自动变量时，已经隐式的将该自动变量初始化为nil；
		 只会在ARC中出现的问题是循环引用：对象之间互相持有，不能被释放；
		 
		在对象创建过程完成的变量对象赋值操作都是strong类型的，因为对象创建并赋值的过程一定会使得变量持有该对象，且将该对象rc设置为1；
	
	_weak： 在使用_weak修饰一个自动变量时，该自动变量被自动初始化为nil；
		将一个强引用修饰的变量赋值给一个弱引用修饰的变量可以是弱引用变量产生对强引用变量所指对象的弱引用；

		如果在一个对象创建并赋值的语句中将变量设定为weak，那么当变量完成创建并给变量赋值时rc为1，但是因为变量类型为weak，所以变量放弃对对象的强引用，导致对象rc-1被释放；
		
		weak的实现：
		与直接储存在散列表中的强引用对象不同的是，系统额外维护了一张weak表，将weak指针指向对象的地址作为value，将weak变量的地址作为key注册到weak表中；
		当weak指针指向的对象被释放时，系统将使用被释放的对象地址快速搜索weak表，将weak表中匹配的weak变量地址设为nil，防止悬垂指针的产生；
		一个对象的地址可能指向了多个不同的weak指针变量，这几个weak指针变量的地址都会被置为nil；
		调用objc_storeweak(&weakpointer,object) 进行注册，调用objc_storewak(&weakpointer,0)进行注销；
		为了防止在取得weak指针指向对象的过程中对象被意外释放导致weak变量直接指向野指针，系统会自动将weak变量指向的对象加入到自动释放池中保证weak变量访问对象时对象未被释放；
		
		weak变量的创建和删除：
		objc_initweak()-->objc_storeweak()      objc_destoryweak()--->objc_storeweak()
		weak变量被赋值时在调用objc_storeweak() 后新增了--->objc_loadWeakRetained()--->objc_autorelease()
		对象的释放：
		objc_release()--->_objc_rootDealloc() --->object_dispose()-->objc_distructInstance()--->objc_clear_deallocating();
		获取对象当前的引用计数的值：
		objc_rootRetainCount()

