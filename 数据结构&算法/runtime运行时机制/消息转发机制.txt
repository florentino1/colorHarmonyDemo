理解消息转发机制：
	在OC中使用objc_msgSend() 或者objc_msgSendSuper()函数进行消息的传递，隐式的传递了两个参数self 和_cmd；
	当消息的接收方receiver没有对应的方法时：这里没有对应的方法指的是对象搜索其类对象/元类对象的方法链表，并沿着继承树向上均未搜索到；
	
	1、动态方法解析----只能动态添加方法；
	此时调用static void resolveInstanceMethod(id inst, SEL sel, Class cls)，注意此方法和对象自己实现的+(BOOL)resolveInstanceMethod:(SEL)secector 不同；
{
    runtimeLock.assertUnlocked();
    ASSERT(cls-&gt;isRealized());
    SEL resolve_sel = @selector(resolveInstanceMethod:);  //获取对象实现的+(BOOL)resolveInstanceMethod:(SEL)secector方法的选择子；

    if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(/*authenticated*/true))) {
        // Resolver not implemented.
        return;
    }   //此处的if判断是为了测试消息发送的接受者对象cls是否实现了+(BOOL)resolveInstanceMethod:(SEL)secector方法；但是在该方法的实现中总是会调用super，NSObject默认实现该方法；

    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;
    bool resolved = msg(cls, resolve_sel, sel);  //此处对消息的发送进行了重定义

    // Cache the result (good or bad) so the resolver doesn't fire next time.
    // +resolveInstanceMethod adds to self a.k.a. cls
    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);    //经过resolveInstanceMethod处理，可能已经动态添加了imp,所以再次获取sel的imp是否存在;如果存在则结束转发，不存在继续转发流程


    //输出一些本函数的异常情况：
    if (resolved  &amp;&amp;  PrintResolving) {
        if (imp) {
            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;
                         &quot;dynamically resolved to %p&quot;,
                         cls-&gt;isMetaClass() ? '+' : '-',
                         cls-&gt;nameForLogging(), sel_getName(sel), imp);
        }
        else {
            // Method resolver didn't add anything?
            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;
                         &quot;, but no new implementation of %c[%s %s] was found&quot;,
                         cls-&gt;nameForLogging(), sel_getName(sel),
                         cls-&gt;isMetaClass() ? '+' : '-',
                         cls-&gt;nameForLogging(), sel_getName(sel));
        }
    }
}
	需要注意到的问题是：在动态方法解析没有向类动态添加方法后，动态解析方法被多调用了一次；

	2、消息接收者替换---只能改变消息的接受者；
	当动态方法解析失败时，调用cf中的：
	(id)forwardingTargetForSelector:(SEL)selector;
	此方法改变消息的接受者，并返回一个对象实例用来响应传入的消息；
	实现可能是：
	{
		if(selector==@selector(dosomework))
		{
			return [someobject alloc];
		}
		return [super forwardingTargetForSelector:selector];
	}
	
	3、完整的消息转发，可以改变消息的接受者、选择子 和为方法追加参数等信息：
	在进入完整的消息转发前需要对方法完成签名才能够进行消息封装为NSIvocation对象的作业：
	-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
	{
		if(aSelector==@selector(dosomework3))
        			return [NSMethodSignature signatureWithObjCTypes:"v@:"];
    		return [super methodSignatureForSelector:aSelector];
	}
	完成方法签名后系统将未处理的消息选择子、参数、目标对象等信息封装到NSInvocation对象中，完成相关的更改后需要调用NSIvocation对象的invokeWithTarget：方法进行消息的再次发送；
	-(void)forwardInvocation:(NSInvocation *)anInvocation
	{
   		 SEL selector=anInvocation.selector;
    		if([[needAClassToDoSomeWork alloc]respondsToSelector:selector])
        			[anInvocation invokeWithTarget:self];
    		else
    		{
        			anInvocation.selector=@selector(work);
        			[anInvocation invokeWithTarget:[needAClassToDoSomeWork alloc]];
    		}
	}

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
********************************************************************************************************************************************************************
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
方法签名:
     NSInvocation对象记录着某个方法的返回值类型、selector、参数和target；其中每一个值都可以被直接进行设置，返回值的类型在NSInvocation对象被分发时自动进行设置；
	只要方法签名对象（返回值类型和参数相同）是同一个对象，那么NSInvocation对象的selector可以被进行替换；
	NSInvocation对象不应该使用allocation、init的方法生成；需要使用invocationWithMethodSignature：

	在显式设定NSInvocation的target后，可以直接调用[someInvocationObject invoke]方法将NSinvocation对象发送到target；
	或者使用[someInvocationObject invokeWith:someTarget]的方法将NSInvocation对象发送到指定的target；
	
	设置方法签名对应的参数，从下标2开始，超出签名参数index就越界报错；0为self，1为selector；
	使用setArgument:atIndex:添加参数时不会强引用它的 argument，如果 argument 在 NSInvocation 执行的时候之前被释放就会造成野指针异常，必要时加上[invocation retainArguments]；

	若有返回值，使用NSInvocation的getReturnValue 来获取返回值，注意该方法仅仅就是把返回数据拷贝到提供的内存缓存区，并不会考虑这里的内存管理，所以有可能出现野指针异常；

	
     NSMethodSignature：只是作为返回值类型信息和方法参数的一份记录；
	可以用instanceMethodSignatureForSelector() 和methodSignatureForSelector()方法获得一个方法选择子的方法签名；
	实例对象能够获得实例方法的方法签名；类对象可以获得类方法和实例方法的方法签名；----但是实例对象不能够获得类方法的方法签名，因为类方法是存储在元类中，实例对象不能访问到元类中的类方法；

	使用signatureWithObjcTypes:对方法进行签名，并返回一个方法签名对象
	
	对于不同的方法而言，如果返回值类型和参数类型相同那么返回的方法签名的对象就是同一个对象，而与方法名和参数名无关；


















































